<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>пазыл</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      background: #f0f0f0;
    }
    #puzzlecontainer {
      border: 1px solid #ccc;
      margin: 20px auto;
      width: 340px;
      height: 340px;
      user-select: none;
      touch-action: none;
    }
    button {
      margin: 5px;
      padding: 8px 12px;
    }
    input {
      margin: 3px 5px;
    }
  </style>
</head>
<body>

<svg id="puzzlecontainer" width="340" height="340" xmlns="http://www.w3.org/2000/svg">
</svg>

<script>

containerWidth = 340;
containerHeight = 340;
const TOP_CURVED = 1;
const TOP_STRAIGHT = 0;

const RIGTH_CURVED = 2;
const RIGHT_STRAIGHT = 0;

const BOTTOM_CURVED = 4;
const BOTTOM_STRAIGHT = 0;

const LEFT_CURVED = 8;
const LEFT_STRAIGHT = 0;

const TOP_SPIKE = 1;
const TOP_HOLE = 0;

const RIGHT_SPIKE = 2;
const RIGHT_HOLE = 0;

const BOTTOM_SPIKE = 4;
const BOTTOM_HOLE = 0;

const LEFT_SPIKE = 8;
const LEFT_HOLE = 0;


function drawPiece(x, y, spikes, curves, size = 120) {
  const svg = document.getElementById("puzzlecontainer");

  const existingPaths = svg.querySelectorAll("path");
  const newId = `piece-${existingPaths.length + 1}`;

  const width = size; // ширина
  const height = size; // высота

  const spike = 0.125; // размер шипа в попугаях

  const isTopOut = (spikes & TOP_SPIKE) ? true : false;
  const isRightOut = (spikes & RIGHT_SPIKE) ? true : false;
  const isBottomOut = (spikes & BOTTOM_SPIKE) ? true : false;
  const isLeftOut = (spikes & LEFT_SPIKE) ? true : false;

  let str = "";

  str += `M ${x} ${y} `;

  // --- Верхняя грань ---
  if (curves & TOP_CURVED) {
    for (let i = 0; i < 1; i++) {
      str += `C 
        ${x + width * 0.2}
        ${y},
        
        ${x + width * 0.5}
        ${isTopOut ? y + spike * height : y - spike * height},
        
        ${x + width * 0.5 - spike * width}
        ${isTopOut ? y - spike * height : y + spike * height } `;

      str += `C 
        ${x + width * 0.5 - 2.0 * spike * width}
        ${isTopOut ? y - 3.0 * spike * height : y + 3.0 * spike * height},
        
        ${x + width * 0.5 + 2.0 * spike * width}
        ${isTopOut ? y - 3.0 * spike * height : y + 3.0 * spike * height},
        
        ${x + width * 0.5 + spike * width}
        ${isTopOut ? y - spike * height : y + spike * height} `;

      str += `C 
        ${x + width * 0.5}
        ${isTopOut ? y + spike * height : y - spike * height},
        
        ${x + width * 0.8}
        ${y},
        
        ${x + width}
        ${y} `;
    }
  } else {
    str += `L ${x + width} ${y} `;
  }

  // --- Правая грань ---
  if (curves & RIGTH_CURVED) {
    for (let i = 0; i < 1; i++) {
      str += `C 
      ${isRightOut ? x + width : x + width}
      ${y + height * 0.2},
        
      ${isRightOut ? x + width - spike * width : x + width + spike * width}
      ${y + height * 0.5},
        
      ${isRightOut ? x + width + spike * width : x + width - spike * width}
      ${y + height * 0.5 - spike * height} `;

      str += `C 
      ${isRightOut ? x + width + 3.0 * spike * width : x + width - 3.0 * spike * width}
      ${y + height * 0.5 - 2.0 * spike * height},
        
      ${isRightOut ? x + width + 3.0 * spike * width : x + width - 3.0 * spike * width}
      ${y + height * 0.5 + 2.0 * spike * height},
        
      ${isRightOut ? x + width + spike * width : x + width - spike * width}
      ${y + height * 0.5 + spike * height} `;


      str += `C
      ${isRightOut ? x + width - spike * width : x + width + spike * width}
      ${y + height * 0.5},
        
      ${isRightOut ? x + width : x + width}
      ${y + height * 0.8},
        
      ${x + width}
      ${y + height} `;
    }
  } else {
    str += `L ${x + width} ${y + height} `;
  }

  // --- Нижняя грань ---
  if (curves & BOTTOM_CURVED) {
    for (let i = 0; i < 1; i++) {
      str += `C 
      ${x + width * 0.8}
      ${isBottomOut ? y + height : y + height},
        
      ${x + width * 0.5}
      ${isBottomOut ? y + height - spike * height : y + height + spike * height},
        
      ${x + width * 0.5 + spike * width}
      ${isBottomOut ? y + height + spike * height : y + height - spike * height} `;

      str += `C 
      ${x + width * 0.5 + 2.0 * spike * width}
      ${isBottomOut ? y + height + 3.0 * spike * height : y + height - 3.0 * spike * height},
        
      ${x + width * 0.5 - 2.0 * spike * width}
      ${isBottomOut ? y + height + 3.0 * spike * height : y + height - 3.0 * spike * height},
        
      ${x + width * 0.5 - spike * width}
      ${isBottomOut ? y + height + spike * height : y + height - spike * height} `;

      str += `S 
      ${x + width * 0.2}
      ${y + height},
       
      ${x}
      ${y + height} `;
    }
  } else {
    str += `L ${x} ${y + height} `;
  }

  // --- Левая грань ---
  if (curves & LEFT_CURVED) {
    for (let i = 0; i < 1; i++) {

      str += `C
        ${x}
        ${y + height * 0.8},
        
        ${isLeftOut ? x + spike * width: x - spike * width} 
        ${y + height * 0.5},
        
        ${isLeftOut ? x - spike * width : x + spike * width}
        ${y + height * 0.5 + spike * height} `;


      str += `C 
        ${isLeftOut ? x - 3.0 * spike * width : x + 3.0 * spike * width}
        ${y + height * 0.5 + 2.0 * spike * height},
        
        ${isLeftOut ? x - 3.0 * spike * width: x + 3.0 * spike * width} 
        ${y + height * 0.5 - 2.0 * spike * height},
        
        ${isLeftOut ? x - spike * width : x + spike * width} 
        ${y + height * 0.5 - spike * height} `;


      str += `C 
        ${isLeftOut ? x + spike * width : x - spike * width} 
        ${y + height * 0.5},
        
        ${x} 
        ${y + height * 0.2},
        
        ${x} 
        ${y} `;
      }
    } else {
      str += `L ${x} ${y} `;
    }

  str += " Z";

  const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
  path.setAttribute("id", newId);
  path.setAttribute("d", str);
  path.setAttribute("fill", "lightblue");
  path.setAttribute("stroke", "#000");
  path.setAttribute("stroke-width", "2");

  svg.appendChild(path);
}

  drawPiece(50, 50, RIGHT_SPIKE | BOTTOM_HOLE, RIGTH_CURVED | BOTTOM_CURVED);
  drawPiece(170, 50, LEFT_HOLE | BOTTOM_SPIKE, BOTTOM_CURVED | LEFT_CURVED);
  drawPiece(170, 170, TOP_HOLE | LEFT_SPIKE, TOP_CURVED | LEFT_CURVED);
  drawPiece(50, 170, TOP_SPIKE | RIGHT_HOLE, TOP_CURVED | RIGTH_CURVED);


  const svg = document.getElementById("puzzlecontainer");

  let viewX = 0;
  let viewY = 0;
  let viewW = containerWidth;
  let viewH = containerHeight;

  function updateViewBox() {
    svg.setAttribute("viewBox", `${viewX} ${viewY} ${viewW} ${viewH}`);
  }

  svg.addEventListener("wheel", function(e) {
    e.preventDefault();

    const rect = svg.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;

    const zoomFactor = 1.1;
    const delta = e.deltaY < 0 ? 1 / zoomFactor : zoomFactor;

    const sceneX = viewX + (mouseX / containerWidth) * viewW;
    const sceneY = viewY + (mouseY / containerHeight) * viewH;

    viewW *= delta;
    viewH *= delta;

    viewX = sceneX - (mouseX / containerWidth) * viewW;
    viewY = sceneY - (mouseY / containerHeight) * viewH;

    // Ограничения
    const min = 50, max = 2000;
    if (viewW < min) { viewW = min; viewH = min; }
    if (viewW > max) { viewW = max; viewH = max; }

    // Пересчёт после ограничений
    viewX = sceneX - (mouseX / containerWidth) * viewW;
    viewY = sceneY - (mouseY / containerHeight) * viewH;

    updateViewBox();
  });
  
// --- Перетаскивание (pan) с учётом выхода за границы SVG ---
let isPanning = false;
let lastX = 0;
let lastY = 0;

function onMouseMove(e) {
  if (!isPanning) return;
  svg.style.userSelect = "none";
  const dx = e.clientX - lastX;
  const dy = e.clientY - lastY;

  // Переводим смещение мыши в смещение сцены (в единицах viewBox)
  const deltaX = (dx / containerWidth) * viewW;
  const deltaY = (dy / containerHeight) * viewH;

  // Сдвигаем viewBox
  viewX -= deltaX;
  viewY -= deltaY;

  updateViewBox();

  lastX = e.clientX;
  lastY = e.clientY;
}

function onMouseUp() {
  if (isPanning) {
    isPanning = false;
    svg.style.cursor = "default";
    // Удаляем глобальные слушатели
    document.removeEventListener("mousemove", onMouseMove);
    document.removeEventListener("mouseup", onMouseUp);
  }
}

svg.addEventListener("mousedown", function(e) {
  // Проверяем, попал ли клик по path (кусочку)
  const target = e.target;
  if (target.tagName === "path") {
    return; // не панорамируем
  }

  // Начинаем пан
  isPanning = true;
  lastX = e.clientX;
  lastY = e.clientY;
  svg.style.cursor = "grabbing";
  e.preventDefault();

  // Включаем слушатели на весь документ
  document.addEventListener("mousemove", onMouseMove);
  document.addEventListener("mouseup", onMouseUp);
});

// Курсор при наведении
svg.addEventListener("mouseenter", () => {
  if (!isPanning) svg.style.cursor = "grab";
});
svg.addEventListener("mouseleave", () => {
  if (!isPanning) svg.style.cursor = "default";
});
// Также обновим cursor при входе, если мышь над SVG, но не над path
svg.addEventListener("mouseover", function(e) {
  if (e.target === svg && !isPanning) {
    svg.style.cursor = "grab";
  } else if (!isPanning) {
    svg.style.cursor = "default";
  }
});

  updateViewBox();
</script>

</body>
</html>